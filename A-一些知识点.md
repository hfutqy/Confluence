### 类的实例化顺序
按照考虑的顺序如下：<br>
静态的 优先于 非静态的<br>
父类 优先于 子类<br>
变量 优先于 代码块<br>
最后再考虑 构造函数，子类构造函数最后实例化<br>

比如父代码块 比 子变量 先一步实例化<br>
静态子类 比 非静态父类 先实例化<br>


#### 总结如下
父类静态变量、 <br>
父类静态代码块、 <br>
子类静态变量、 <br>
子类静态代码块、 <br>
父类非静态变量（父类实例成员变量）、 <br>
父类构造函数、 <br>
子类非静态变量（子类实例成员变量）、 <br>
子类构造函数。

### JVM内存参数
#### -Xms 、-Xmx、-XX:newSize、-XX:MaxnewSize、-Xmn <br>
1、*****-Xms ：表示java虚拟机堆区内存初始内存分配的大小***** ，通常为操作系统可用内存的1/64大小即可，但仍需按照实际情况进行分配。有可能真的按照这样的一个规则分配时，设计出的软件还没有能够运行得起来就挂了。<br>
2、*****-Xmx： 表示java虚拟机堆区内存可被分配的最大上限***** ，通常为操作系统可用内存的1/4大小。但是开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。<br>

一般来讲对于堆区的内存分配只需要对上述两个参数进行合理配置即可，但是如果想要进行更加精细的分配还可以对堆区内存进一步的细化，那就要用到下面的三个参数了-XX:newSize、-XX:MaxnewSize、-Xmn。当然这源于对堆区的进一步细化分：新生代、中生代、老生代。java中每新new一个对象所占用的内存空间就是新生代的空间，当java垃圾回收机制对堆区进行资源回收后，那些新生代中没有被回收的资源将被转移到中生代，中生代的被转移到老生代。而接下来要讲述的三个参数是用来控制新生代内存大小的。<br>
 1、*****-XX:newSize：表示新生代初始内存的大小***** ， 应该小于 -Xms的值；<br>
 2、*****-XX:MaxnewSize：表示新生代可被分配的内存的最大上限***** ；当然这个值应该小于 -Xmx的值；<br>
 3、-Xmn：至于这个参数则是对 -XX:newSize、-XX:MaxnewSize两个参数的同时配置，也就是说如果通过-Xmn来配置新生代的内存大小，那么-XX:newSize = -XX:MaxnewSize = -Xmn，虽然会很方便，但需要注意的是这个参数是在JDK1.4版本以后才使用的。
 <br>
 上面所述即为java虚拟机对外提供的可配置堆区的参数，接下来讲述java虚拟机对非堆区内存配置的两个参数：
    <br>
1、*****-XX:PermSize：表示非堆区初始内存分配大小***** ，其缩写为permanent size（持久化内存）<br>
2、*****-XX:MaxPermSize：表示对非堆区分配的内存的最大上限***** 。
    <br>
这里面非常要注意的一点是：在配置之前一定要慎重的考虑一下自身软件所需要的非堆区内存大小，因为此处内存是不会被java垃圾回收机制进行处理的地方。并且更加要注意的是 最大堆内存与最大非堆内存的和绝对不能够超出操作系统的可用内存。<br>


### 六种负载均衡算法
1、轮询法
　　将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。

2、随机法
     通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，
其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。

3、源地址哈希法
     源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。

4、加权轮询法
　　不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。

5、加权随机法
     与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。

6、最小连接数法（推荐）
     最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前
积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。
<br>
7、最少最近算法 Least Recently Used
内存区域 内存区域是一个使用最近最少算法（Least Recently Used,LRU）的纯内存缓存区域.当内存缓存区域满时,LRU 会删除最近最少使用的缓存数据.

### Spring的AOP和IOC通俗理解
spring 提过了AOP和IOC两大利器，很好用的，简单来说一下：
IOC最常用，常见的就是@Service和@Resource两注解，在用某个service时不需要再new，控制反转为你创造了容器，帮你new了一个全局可以用的service对象；减少内存占用、简化代码编写、
AOP即切面方法，@Aspect注解声明的方法，它应该是一个很常用的方法，比如日志记录，很多项目方法里都要复写的；面向切面的思想，大概就是说在数据流上树个切面，所以的方法都要路过这个切面，可以是之前之后或指定在切面方法执行到某个地方再走项目方法；减少了代码量，也方便统一执行；感觉有点像拦截器。

### 并发和并行
并发，排队发起，只需要一个cpu跑，cpu跑过程遇到IO（IO耗时较多，不并发的话就是等待IO结束，这个期间cpu就浪费了）就继续跑下一个请求，让cpu几乎处于一直在使用的状态。
并行可以理解为多个并发的队列一起执行，要求多个cpu
画图：
```
并发  	     并行
        |         - - - -|
        |         - - - -|
- - - -	|         - - - -|
        |         - - - -|
```
