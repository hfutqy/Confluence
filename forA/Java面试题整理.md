零、自我介绍
1. 工作经历，为什么离职，之前的产出，对自己做过的项目的掌握  

一、数据结构相关
1. HashMap的结构，如何解决Hash冲突，如何扩容
2. ConcurrentHashMap如何做到并发安全的
3. HashTable、HashSet、TreeSet
4. 一棵二叉查找树如果满足下面的红黑性质，则为一棵红黑树：
1) 每个结点是或是红的，或是黑的。
2) 根结点是黑的。
3) 每个叶结点（nil[T]）是黑的。
4) 如果一个结点是红的，那么它的两个儿子是黑的。
5) 对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。


二、 多线程
1. 多线程的几种实现方式，Runnable接口，Thread类，Callable接口，Furture  
2. 线程池的实现方式，executor接口，executors实现类    
newFixedThreadPool(),newSingleThreadExecutor(),newCachedThreadPool()等
3. ThreadLocal对象，既是全局入库可见，又是线程安全的，对每个线程存储的数据都是各自独立的。可能有内存泄漏，key会消失，value既是处于游离态。
4. 锁相关，ReentrantLock,自旋锁，可重入锁等  
5. java.util.concurrent包里的实现类  
6. volatile 如何实现对象的可见性（不允许线程内部缓存和指令重排序）  
但是volatile int a=0; a++这个动作任然有线程安全问题。
7. 线程间如何通信,进程间如何通信?    
线程：1). 共享变量; 2),wait, notify; 3)Lock/Condition机制; 4).管道机制  
进程：管道、命名管道、信号（Signal）、消息（Message）队列、共享内存、内存映射、信号量、套接字  
8. notify 和 notifyAll有什么区别？  
均能唤醒正在等待的线程，并且均是最后只有一个线程获取资源对象的锁。  
notify() 只能唤醒一个线程，而notifyall()能够唤醒所有的线程，当线程被唤醒以后所有被唤醒的线程竞争获取资源对象的锁，其中只有一个能够得到对象锁，执行代码。



三、设计模式
1. 单例，注意构造函数要私有，对象要静态的，有懒汉、饿汉、volatile+双重检查锁，静态内部类多种实现方式。（除了饿汉都是延迟加载）
2. 门面模式
3. 观察者模式
4. 代理模式

四、mysql
1. 索引，B+树，联合索引，索引的设计
2. 事物隔离级别，Read-uncommitted,Read-committed,repeatable-read,
serializable。后三者依次解决了脏读、不可重复读、幻读的问题。如何理解幻读？
3. ACID，原子性（Atomicity，要么执行要么不执行，原子操作）、一致性（Consistency，写ok后读到写ok的值，保持一致）、隔离性（Isolation,这就是隔离级别了）、持久性（Durability，操作会落地到磁盘，不会丢失）
4. sql优化+索引
```
select * from t where c - 1 = 1000;这个不会用上c的索引。运算。
select * from t where pow(c,2) = 1000;这个也不会用上索引。函数。
```
5. 主键索引和非主键索引是有区别的，主键索引存放的值是整行字段的数据，而非主键索引上存放的值不是整行字段的数据，而且存放主键字段的值。走哪个索引，是会采样的。
而一个索引的基数越大(区分度)，意味着走索引查询越有优势。  
由于采样统计的失误，导致系统没有走索引，而是走了全表扫描，而这，也是导致我们 SQL 语句执行的很慢的原因。
```
强制走索引
select * from t force index(a) where c < 100 and c < 100000;
```
一个 SQL 执行的很慢，我们要分两种情况讨论：  
1、大多数情况下很正常，偶尔很慢，则有如下原因  
(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。  
(2)、执行的时候，遇到锁，如表锁、行锁。  
2、这条 SQL 语句一直执行的很慢，则有如下原因。  
(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。  
(2)、数据库选错了索引。  

五、redis

六、mongo

七、kafka、zookeeper





X、拓展
1. 实现全局流水唯一id（mysql乐观锁，redis队列）

Y、算法题
1. 查找一个栈里的最小值
2. 全排列，即查找最长公共子序列
3. 加和最大的子序列
4. 数组中找2个数的和为指定数
5. n个有序数组，求top k
6. 两个有序数组，求合并后的中位数
7.
